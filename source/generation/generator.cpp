// Copyright (c) 2023 Jacob R. Green
// All Rights Reserved.

#include "generator.hpp"
#include "gen_var.hpp"

#include "../paths.hpp"

#include "../common.hpp"

#include "../timer.hpp"

#include "gen_var.hpp"
#include "gen_func.hpp"
#include "gen_struct.hpp"

auto forward_decl_structs(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefStruct) {
      write_forward_decl(writer, ptr_cast<StructDefinition>(node));
      writer << newline;
    }
  }
}

auto forward_decl_objects(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;
  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefObject) {
      empty = false;
      // todo : implement
    }
  }

  if (!empty) {
    writer << newline;
  }
}

auto forward_decl_aliases(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefObject) {
      empty = false;
      // todo : implement
    }
  }

  if (!empty) {
    writer << newline;
  }
}

auto forward_declare_funcs(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefFunc) {
      empty = false;
      write_forward_decl(writer, ptr_cast<FuncDefinition>(node));
      writer << newline;
    }
  }

  if (!empty) {
    writer << newline;
  }
}

auto forward_declare_vars(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefVar) {
      empty = false;
      write_def(writer, ptr_cast<VarDefinition>(node));
      writer << newline;
    }
  }

  if (!empty) {
    writer << newline;
  }
}

auto forward_declare(std::ostream& writer, const std::shared_ptr<SyntaxTree>& source) -> void {
  writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline << newline;

  auto& nodes = source->nodes();
  forward_decl_structs(writer, nodes);
  writer << newline;
  forward_decl_objects(writer, nodes);
  forward_decl_aliases(writer, nodes);
  forward_declare_funcs(writer, nodes);
  forward_declare_vars(writer, nodes);
}

auto write_definitions(std::ostream& writer, const std::shared_ptr<SyntaxTree>& source) -> void {
  for (auto& node : source->nodes()) {
    switch (node->kind()) {
      case SyntaxKind::DefFunc: {
        write_function_definition(writer, ptr_cast<FuncDefinition>(node));
        break;
      }
      case SyntaxKind::DefStruct: {
        write_struct_definition(writer, ptr_cast<StructDefinition>(node));
        break;
      }
    }
    writer << newline;
  }
}

auto write_source_header(std::ostream& writer, const fs::path& rel_path) -> void {
  writer << "/*" << newline << " *  Generated by Typhon Compiler" << newline
         << " *      Source File : " << rel_path << newline << " */" << newline << newline;
}

const auto includes = std::vector<std::string_view>{"<cstdint>"};

auto write_includes(std::ostream& writer) {
  for (auto& include : includes) {
    writer << "#include " << include << newline;
  }
  if (!includes.empty()) {
    writer << newline;
  }
}

auto generate_source_file(const fs::path& rel_path, const std::shared_ptr<SyntaxTree>& source)
    -> void {
  auto src_file_path = rel_src_path_to_gen_src_file_path(rel_path);
  fs::create_directories(src_file_path.parent_path());

  auto writer = std::ofstream{src_file_path};

  write_source_header(writer, rel_path);
  write_includes(writer);
  forward_declare(writer, source);
  write_definitions(writer, source);
}

auto generate(const fs::path& rel_path, const std::shared_ptr<SyntaxTree>& source) -> void {
  TRACE_TIMER("generate");
  generate_source_file(rel_path, source);
}
