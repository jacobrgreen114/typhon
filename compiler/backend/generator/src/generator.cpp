// Copyright (c) 2023 Jacob R. Green
// All Rights Reserved.

#include "generator.hpp"
#include "gen_var.hpp"

#include "paths.hpp"

#include "common.hpp"

#include "timer.hpp"

#include "gen_var.hpp"
#include "gen_func.hpp"
#include "gen_struct.hpp"
#include "gen_object.hpp"

#define FIND_IF_OPTIMIZATION false

auto find_if_def_var(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefVar;
  });
}

auto find_if_def_func(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefFunc;
  });
}

auto find_if_def_struct(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefStruct;
  });
}

auto find_if_def_object(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefObject;
  });
}

auto forward_decl_structs(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& strc : tree.structs()) {
    writer << newline;
    write_forward_decl(writer, deref(strc));
  }
}

auto forward_decl_objects(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& object : tree.objects()) {
    writer << newline;
    write_forward_decl(writer, deref(object));
  }
}

auto forward_decl_aliases(std::ostream& writer, const SyntaxTree& nodes, GeneratedFile file) {
  // for (auto& node : nodes) {
  //   if (node->kind() == SyntaxKind::DefObject) {
  //     empty = false;
  //     // todo : implement
  //   }
  // }
}

auto forward_declare_funcs(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& fn : tree.functions()) {
    write_forward_decl(writer, deref(fn));
  }
}

auto forward_declare_vars(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& var : tree.variables()) {
    write_forward_decl(writer, deref(ptr_cast<VariableDefinition>(var.get())));
  }
}

auto forward_declare_source(std::ostream& writer, const SyntaxTree& tree) -> void {
  // writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline;

  // forward_decl_structs(writer, tree, GeneratedFile::Source);
  // writer << newline;
  // forward_decl_objects(writer, tree, GeneratedFile::Source);
  // writer << newline;
  // forward_decl_aliases(writer, nodes);
  // writer << newline;
  // forward_declare_funcs(writer, tree, GeneratedFile::Source);
  // writer << newline;
}

auto forward_declare_internal(std::ostream& writer, const SyntaxTree& tree) -> void {
  writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline << newline;

  forward_declare_vars(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
  forward_decl_structs(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
  forward_decl_objects(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
  //forward_decl_aliases(writer, nodes);
  //writer << newline;
  forward_declare_funcs(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
}

auto write_definitions(std::ostream& writer, const SyntaxTree& source) -> void {
  for (auto& var : source.variables()) {
    write_def(writer, deref(var));
  }

  for (auto& str : source.structs()) {
    writer << newline;
    write_struct_definition(writer, deref(str));
  }

  for (auto& object : source.objects()) {
    writer << newline;
    write_object_definition(writer, deref(object));
  }

  for (auto& fn : source.functions()) {
    writer << newline;
    write_definition(writer, deref(fn));
  }
}

auto write_source_header(std::ostream& writer, const fs::path& rel_path) -> void {
  writer << "/*" << newline << " *  Generated by Typhon Compiler" << newline
         << " *      Source File : " << rel_path << newline << " */" << newline << newline;
}

const auto includes = std::vector<std::string_view>{"<cstdint>"};

auto write_includes(std::ostream& writer) {
  for (auto& include : includes) {
    writer << "#include " << include << newline;
  }
  if (!includes.empty()) {
    writer << newline;
  }
}

auto generate_source_file(const NameSpace& ns, const SyntaxTree& syntax_tree) -> void {
  auto& source        = deref(syntax_tree.source());
  auto& src_file_path = source.gen_source_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());
  auto writer = std::ofstream{src_file_path};

  TRACE_TIMER("Generator");
  write_source_header(writer, source.rel_path());

  writer << "#include \"" << ns.file_name() << "\"" << newline << newline;

  forward_declare_source(writer, syntax_tree);
  write_definitions(writer, syntax_tree);
}

auto generate_internal_header(const NameSpace& ns, const SyntaxTree& syntax_tree) -> void {
  auto& source        = deref(syntax_tree.source());
  auto& src_file_path = source.gen_header_internal_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());
  auto writer = std::ofstream{src_file_path};

  TRACE_TIMER("Generator");
  write_source_header(writer, source.rel_path());

  writer << "#pragma once" << newline << newline;

  writer << "#include \"" << ns.file_name() << '"' << newline << newline;

  forward_declare_internal(writer, syntax_tree);
}

auto generate_namespace_header(const ProjectConfig& config, const NameSpace& ns) {
  auto writer = std::ofstream{config.dir_gen_source() / ns.file_name()};

  write_source_header(writer, {});
  writer << "#pragma once" << newline << newline;

  if (ns.parent()) {
    writer << "#include \"" << deref(ns.parent()).file_name() << '"' << newline;
  } else {
    writer << "#include \"../../__builtins.hpp\"" << newline << newline;
  }

  for (auto& ptree : ns.trees()) {
    auto& tree = deref(ptree);
    writer << "#include \"" << deref(tree.source()).gen_header_internal_path().filename().string()
           << '"' << newline;
  }
}

auto generate(const ProjectConfig& config, const NameSpace& ns) -> void {
  generate_namespace_header(config, ns);
  for (auto& ptree : ns.trees()) {
    auto& tree = deref(ptree);
    generate_internal_header(ns, tree);
    generate_source_file(ns, tree);
  }

  for (auto& psub : ns.sub_spaces()) {
    generate(config, deref(psub));
  }
}

auto write_cmake_source_paths(const ProjectConfig& config,
                              std::ostream& writer,
                              const NameSpace& ns) -> void {
  for (auto& ptree : ns.trees()) {
    auto& tree     = deref(ptree);

    auto file_name = deref(tree.source()).gen_source_path();

    auto src_path  = relative(file_name, config.dir_build()).string();
    std::replace_if(
        src_path.begin(), src_path.end(), [](auto c) { return c == '\\'; }, '/');

    writer << indent << '"' << src_path << '"' << newline;
  }

  for (auto& psub : ns.sub_spaces()) {
    write_cmake_source_paths(config, writer, deref(psub));
  }
}

auto generate_cmake(const ProjectConfig& config, const ProjectTree& source) -> void {
  const auto cmake_file_path = config.dir_build() / "CMakeLists.txt";

  auto writer                = std::ofstream{cmake_file_path};
  writer << "cmake_minimum_required(VERSION 3.20)" << newline << newline << "project( "
         << config.name() << " )" << newline << newline;

  auto bin               = fs::absolute(config.dir_binary());
  auto build             = fs::absolute(config.dir_build());
  auto rel_bin_dir = fs::proximate(bin, build).string();
  std::replace_if(rel_bin_dir.begin(), rel_bin_dir.end(), [](auto c){ return c == '\\';}, '/');


  writer << "set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_SOURCE_DIR}/" << rel_bin_dir
         << "\")" << newline;
  writer << "set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${CMAKE_SOURCE_DIR}/" << rel_bin_dir
         << "\")" << newline;
  writer << "set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_SOURCE_DIR}/" << rel_bin_dir
         << "\")" << newline << newline;

  auto binary_type = config.binary_type();
  if (binary_type == BinaryType::Exe) {
    writer << "add_executable( ";
  } else {
    writer << "add_library( ";
  }

  writer << config.name();

  if (binary_type == BinaryType::Dyn) {
    writer << " SHARED";
  }

  writer << newline << indent << "\"../../__main.cpp\"" << newline;
  write_cmake_source_paths(config, writer, deref(source.root()));
  writer << ')' << newline;
}

auto generate(const ProjectConfig& config, const ProjectTree& source) -> void {
  generate(config, deref(source.root()));
  generate_cmake(config, source);

  // Build
  const auto build_path = config.dir_build() / "build";
  {
    const auto cmake_command = std::string{"cmake -S \""} + config.dir_build().string() +
                               "\" -B \"" + build_path.string() + '"';

    std::cout << "[Typhon] CMake Command : " << cmake_command << std::endl;
    TRACE_TIMER("CMake");
    auto cmake_result = system(cmake_command.c_str());
    if (cmake_result != 0) {
      std::cerr << "Error : failed to configure cmake." << std::endl;
      exit(-1);
    }
  }

  // Compile
  {
    const auto solution_file = build_path / config.name() += ".sln";

    const auto build_command = std::string{"msbuild "} + '"' + solution_file.string() + '"';

    std::cout << "[Typhon] Build Command : " << build_command << std::endl;
    TRACE_TIMER("Build");
    auto compile_result = system(build_command.c_str());
    if (compile_result != 0) {
      std::cerr << "Error : failed to compile." << std::endl;
      exit(-1);
    }
  }
}
