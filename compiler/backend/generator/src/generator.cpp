// Copyright (c) 2023 Jacob R. Green
// All Rights Reserved.

#include "generator.hpp"
#include "gen_var.hpp"

#include "paths.hpp"

#include "common.hpp"

#include "timer.hpp"

#include "gen_var.hpp"
#include "gen_func.hpp"
#include "gen_struct.hpp"

#define FIND_IF_OPTIMIZATION false

auto find_if_def_var(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefVar;
  });
}

auto find_if_def_func(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefFunc;
  });
}

auto find_if_def_struct(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefStruct;
  });
}

auto find_if_def_object(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefObject;
  });
}

auto forward_decl_structs(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

#if FIND_IF_OPTIMIZATION
  for (auto it = find_if_def_struct(nodes.begin(), nodes.end()); it != nodes.end();
       it      = find_if_def_struct(++it, nodes.end())) {
    empty = false;
    write_forward_decl(writer, ptr_cast<StructDefinition>(*it));
    writer << newline;
  }
#else
  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefStruct) {
      empty = false;
      write_forward_decl(writer, ptr_cast<StructDefinition>(node));
      writer << newline;
    }
  }
#endif

  if (!empty) {
    writer << newline;
  }
}

auto forward_decl_objects(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

#if FIND_IF_OPTIMIZATION
  for (auto it = find_if_def_object(nodes.begin(), nodes.end()); it != nodes.end();
       it      = find_if_def_object(++it, nodes.end())) {
    empty = false;
    // todo : implement
  }
#else
  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefObject) {
      empty = false;
      // todo : implement
    }
  }
#endif

  if (!empty) {
    writer << newline;
  }
}

auto forward_decl_aliases(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefObject) {
      empty = false;
      // todo : implement
    }
  }

  if (!empty) {
    writer << newline;
  }
}

auto forward_declare_funcs(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

#if FIND_IF_OPTIMIZATION
  for (auto it = find_if_def_func(nodes.begin(), nodes.end()); it != nodes.end();
       it      = find_if_def_func(++it, nodes.end())) {
    empty = false;
    write_forward_decl(writer, ptr_cast<FuncDefinition>(*it));
    writer << newline;
  }
#else
  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefFunc) {
      empty = false;
      write_forward_decl(writer, ptr_cast<FuncDefinition>(node));
      writer << newline;
    }
  }
#endif

  if (!empty) {
    writer << newline;
  }
}

auto forward_declare_vars(std::ostream& writer, const SyntaxTree::NodeArray& nodes) {
  auto empty = true;

#if FIND_IF_OPTIMIZATION
  for (auto it = find_if_def_var(nodes.begin(), nodes.end()); it != nodes.end();
       it      = find_if_def_var(++it, nodes.end())) {
    empty = false;
    write_def(writer, ptr_cast<VarDefinition>(*it));
    writer << newline;
  }
#else
  for (auto& node : nodes) {
    if (node->kind() == SyntaxKind::DefVar) {
      empty = false;
      write_def(writer, ptr_cast<VarDefinition>(node));
      writer << newline;
    }
  }
#endif

  if (!empty) {
    writer << newline;
  }
}

auto forward_declare(std::ostream& writer, const std::shared_ptr<SyntaxTree>& source) -> void {
  writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline << newline;

  auto& nodes = source->nodes();
  forward_decl_structs(writer, nodes);
  writer << newline;
  forward_decl_objects(writer, nodes);
  //forward_decl_aliases(writer, nodes);
  forward_declare_funcs(writer, nodes);
  forward_declare_vars(writer, nodes);
}

auto write_definitions(std::ostream& writer, const std::shared_ptr<SyntaxTree>& source) -> void {
  for (auto& node : source->nodes()) {
    switch (node->kind()) {
      case SyntaxKind::DefFunc: {
        write_function_definition(writer, ptr_cast<FuncDefinition>(node));
        break;
      }
      case SyntaxKind::DefStruct: {
        write_struct_definition(writer, ptr_cast<StructDefinition>(node));
        break;
      }
    }
    writer << newline;
  }
}

auto write_source_header(std::ostream& writer, const fs::path& rel_path) -> void {
  writer << "/*" << newline << " *  Generated by Typhon Compiler" << newline
         << " *      Source File : " << rel_path << newline << " */" << newline << newline;
}

const auto includes = std::vector<std::string_view>{"<cstdint>"};

auto write_includes(std::ostream& writer) {
  for (auto& include : includes) {
    writer << "#include " << include << newline;
  }
  if (!includes.empty()) {
    writer << newline;
  }
}

auto generate_source_file(const std::shared_ptr<SyntaxTree>& syntax_tree) -> void {
  auto& source        = syntax_tree->source();
  auto& src_file_path = source->gen_source_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());

  auto writer = std::ofstream{src_file_path};

  write_source_header(writer, source->rel_path());
  write_includes(writer);
  forward_declare(writer, syntax_tree);
  write_definitions(writer, syntax_tree);
}

auto generate(const std::shared_ptr<SyntaxTree>& source) -> void {
  TRACE_TIMER("generate");
  generate_source_file(source);
}
