// Copyright (c) 2023 Jacob R. Green
// All Rights Reserved.

#include "generator.hpp"

#include "gen_var.hpp"
#include "gen_func.hpp"
#include "gen_struct.hpp"
#include "gen_object.hpp"

#include "gen_pst.hpp"

#include "common.hpp"
#include "timer.hpp"

auto forward_decl_structs(std::ostream& writer, const SyntaxTree& tree) {
  for (auto& strc : tree.structs()) {
    writer << newline;
    write_forward_decl(writer, deref(strc));
  }
}

auto forward_decl_objects(std::ostream& writer, const SyntaxTree& tree) {
  for (auto& object : tree.objects()) {
    writer << newline;
    write_forward_decl(writer, deref(object));
  }
}

auto forward_decl_aliases(std::ostream& writer, const SyntaxTree& nodes) {
  // for (auto& node : nodes) {
  //   if (node->kind() == SyntaxKind::DefObject) {
  //     empty = false;
  //     // todo : implement
  //   }
  // }
}

auto forward_declare_funcs(std::ostream& writer, const SyntaxTree& tree) {
  for (auto& fn : tree.functions()) {
    write_forward_decl(writer, deref(fn));
  }
}

auto forward_declare_vars(std::ostream& writer, const SyntaxTree& tree) {
  for (auto& var : tree.variables()) {
    write_forward_decl(writer, deref(ptr_cast<VariableDefinition>(var.get())));
  }
}

auto forward_declare_source(std::ostream& writer, const SyntaxTree& tree) -> void {
  // writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline;

  // forward_decl_structs(writer, tree, GeneratedFile::Source);
  // writer << newline;
  // forward_decl_objects(writer, tree, GeneratedFile::Source);
  // writer << newline;
  // forward_decl_aliases(writer, nodes);
  // writer << newline;
  // forward_declare_funcs(writer, tree, GeneratedFile::Source);
  // writer << newline;
}

auto forward_declare_internal(std::ostream& writer, const SyntaxTree& tree) -> void {
  writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline << newline;

  forward_declare_vars(writer, tree);
  forward_decl_structs(writer, tree);
  forward_decl_objects(writer, tree);
  //forward_decl_aliases(writer, nodes);
  forward_declare_funcs(writer, tree);
}

auto write_definitions(std::ostream& writer, const SyntaxTree& source) -> void {
  for (auto& var : source.variables()) {
    write_def(writer, deref(var));
  }

  for (auto& str : source.structs()) {
    writer << newline;
    write_struct_definition(writer, deref(str));
  }

  for (auto& object : source.objects()) {
    writer << newline;
    write_object_definition(writer, deref(object));
  }

  for (auto& fn : source.functions()) {
    writer << newline;
    write_definition(writer, deref(fn));
  }
}

auto write_source_header(std::ostream& writer, const fs::path& rel_path) -> void {
  writer << "/*" << newline << " *  Generated by Typhon Compiler" << newline
         << " *      Source File : " << rel_path << newline << " */" << newline << newline;
}

// const auto includes = std::vector<std::string_view>{"cstdint"};
//
// auto write_includes(std::ostream& writer) {
//   for (auto& include : includes) {
//     writer << "#include " << include << newline;
//   }
//   if (!includes.empty()) {
//     writer << newline;
//   }
// }

auto generate_source_file(const NameSpace& ns, const SyntaxTree& syntax_tree) -> void {
  auto& source        = deref(syntax_tree.source());
  auto& src_file_path = source.gen_source_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());
  auto writer = std::ofstream{src_file_path};

  TRACE_TIMER("Generator");
  write_source_header(writer, source.rel_path());

  write_include(writer, ns.file_name()) << newline;

  forward_declare_source(writer, syntax_tree);
  write_definitions(writer, syntax_tree);
}

auto generate_internal_header(const NameSpace& ns, const SyntaxTree& syntax_tree) -> void {
  auto& source        = deref(syntax_tree.source());
  auto& src_file_path = source.gen_header_internal_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());
  auto writer = std::ofstream{src_file_path};

  TRACE_TIMER("Generator");
  write_source_header(writer, source.rel_path());

  writer << "#pragma once" << newline << newline;

  for (auto& pcinclude : syntax_tree.cincludes()) {
    auto& cinclude = deref(pcinclude);
    write_include(writer, cinclude.name());
  }

  writer << newline;

  // todo : move to seperate function
  for (auto& pctype : syntax_tree.ctypes()) {
    auto& ctype = deref(pctype);
    writer << "using " << identifer_prefix << ctype.name() << " = " << ctype.c_name() << ';'
           << newline;
  }

  writer << newline;
  write_include(writer, ns.file_name()) << newline;

  forward_declare_internal(writer, syntax_tree);
}

auto generate_namespace_header(const ProjectConfig& config, const NameSpace& ns) {
  auto writer = std::ofstream{config.dir_gen_source() / ns.file_name()};

  write_source_header(writer, {});
  writer << "#pragma once" << newline << newline;

  if (ns.parent()) {
    write_include(writer, deref(ns.parent()).file_name());
  }

  for (auto& ptree : ns.trees()) {
    auto& tree = deref(ptree);
    write_include(writer, deref(tree.source()).gen_header_internal_path().filename().string());
  }
}

auto generate(const ProjectConfig& config, const NameSpace& ns) -> void {
  generate_namespace_header(config, ns);
  for (auto& ptree : ns.trees()) {
    auto& tree = deref(ptree);
    generate_internal_header(ns, tree);
    generate_source_file(ns, tree);
  }

  for (auto& psub : ns.sub_spaces()) {
    generate(config, deref(psub));
  }
}

auto write_cmake_source_paths(const ProjectConfig& config,
                              std::ostream& writer,
                              const NameSpace& ns) -> void {
  for (auto& ptree : ns.trees()) {
    auto& tree     = deref(ptree);

    auto file_name = deref(tree.source()).gen_source_path();

    auto src_path  = relative(file_name, config.dir_build()).string();
    std::replace_if(
        src_path.begin(), src_path.end(), [](auto c) { return c == '\\'; }, '/');

    writer << indent << '"' << src_path << '"' << newline;
  }

  for (auto& psub : ns.sub_spaces()) {
    write_cmake_source_paths(config, writer, deref(psub));
  }
}

constexpr auto cmake_minimim_version = std::string_view{"cmake_minimum_required(VERSION 3.20)"};

constexpr auto cmake_project_prefix  = std::string_view{"project( "};
constexpr auto cmake_project_postfix = std::string_view{" )"};

constexpr auto cmake_exe_prefix      = std::string_view{"add_executable( "};
constexpr auto cmake_lib_prefix      = std::string_view{"add_library( "};

constexpr auto cmake_lists_file_name = std::string_view{"CMakeLists.txt"};

auto generate_cmake(const ProjectConfig& config, const ProjectTree& source) -> void {
  const auto cmake_file_path = config.dir_build() / cmake_lists_file_name;

  auto writer                = std::ofstream{cmake_file_path};
  writer << cmake_minimim_version << newline << newline;
  writer << cmake_project_prefix << config.name() << cmake_project_postfix << newline << newline;

  const auto bin   = fs::absolute(config.dir_binary());
  const auto build = fs::absolute(config.dir_build());
  auto rel_bin_dir = fs::proximate(bin, build).string();
  std::replace_if(
      rel_bin_dir.begin(), rel_bin_dir.end(), [](auto c) { return c == '\\'; }, '/');

  writer << "set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_SOURCE_DIR}/" << rel_bin_dir << "\")"
         << newline;
  writer << "set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${CMAKE_SOURCE_DIR}/" << rel_bin_dir << "\")"
         << newline;
  writer << "set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_SOURCE_DIR}/" << rel_bin_dir << "\")"
         << newline << newline;

  const auto binary_type = config.binary_type();
  if (binary_type == BinaryType::Exe) {
    writer << cmake_exe_prefix;
  } else {
    writer << cmake_lib_prefix;
  }

  writer << config.name();

  if (binary_type == BinaryType::Dyn) {
    writer << " SHARED";
  }

  if (binary_type == BinaryType::Exe) {
    writer << newline << indent << "\"../../__main.cpp\"" << newline;
  }

  write_cmake_source_paths(config, writer, deref(source.root()));
  writer << ')' << newline;
}

// todo : redirect cmake and compiler output to pipe
auto make(const ProjectConfig& config, const fs::path& build_path) -> void {
  const auto cmake_command = std::string{"cmake -S \""} + config.dir_build().string() + "\" -B \"" +
                             build_path.string() + '"';

  std::cout << "[Typhon] CMake Command : " << cmake_command << std::endl;
  TRACE_TIMER("CMake");
  const auto cmake_result = system(cmake_command.c_str());
  if (cmake_result != 0) {
    std::cerr << "Error : failed to configure cmake." << std::endl;
    exit(-1);
  }
}

// todo : build command needs to be implemented for different build systems
auto build(const ProjectConfig& config, const fs::path& build_path) -> void {
  const auto solution_file = build_path / config.name() += ".sln";
  const auto build_command = std::string{"msbuild \""} + solution_file.string() + '"';

  std::cout << "[Typhon] Build Command : " << build_command << std::endl;
  TRACE_TIMER("Build");
  const auto compile_result = system(build_command.c_str());
  if (compile_result != 0) {
    std::cerr << "Error : failed to compile." << std::endl;
    exit(-1);
  }
}

auto compile(const ProjectConfig& config) -> void {
  const auto build_path = config.dir_build() / "build";
  make(config, build_path);
  build(config, build_path);
}

auto generate(const ProjectConfig& config, const ProjectTree& project_tree) -> void {
  generate(config, deref(project_tree.root()));
  generate_public_symbol_table(config, project_tree);
  generate_cmake(config, project_tree);
  compile(config);
}
