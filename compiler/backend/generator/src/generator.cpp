// Copyright (c) 2023 Jacob R. Green
// All Rights Reserved.

#include "generator.hpp"
#include "gen_var.hpp"

#include "paths.hpp"

#include "common.hpp"

#include "timer.hpp"

#include "gen_var.hpp"
#include "gen_func.hpp"
#include "gen_struct.hpp"
#include "gen_object.hpp"

#define FIND_IF_OPTIMIZATION false

auto find_if_def_var(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefVar;
  });
}

auto find_if_def_func(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefFunc;
  });
}

auto find_if_def_struct(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefStruct;
  });
}

auto find_if_def_object(auto begin, auto end) {
  return std::find_if(std::execution::par, begin, end, [](auto& node) -> bool {
    return node->kind() == SyntaxKind::DefObject;
  });
}

auto forward_decl_structs(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& strc : tree.structs()) {
    writer << newline;
    write_forward_decl(writer, deref(strc));
  }
}

auto forward_decl_objects(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& object : tree.objects()) {
    writer << newline;
    write_forward_decl(writer, deref(object));
  }
}

auto forward_decl_aliases(std::ostream& writer, const SyntaxTree& nodes, GeneratedFile file) {
  // for (auto& node : nodes) {
  //   if (node->kind() == SyntaxKind::DefObject) {
  //     empty = false;
  //     // todo : implement
  //   }
  // }
}

auto forward_declare_funcs(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& fn : tree.functions()) {
    write_forward_decl(writer, deref(fn));
  }
}

auto forward_declare_vars(std::ostream& writer, const SyntaxTree& tree, GeneratedFile file) {
  for (auto& var : tree.variables()) {
    write_forward_decl(writer, deref(ptr_cast<VariableDefinition>(var.get())));
  }
}

auto forward_declare_source(std::ostream& writer, const SyntaxTree& tree) -> void {
  // writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline;

  // forward_decl_structs(writer, tree, GeneratedFile::Source);
  // writer << newline;
  // forward_decl_objects(writer, tree, GeneratedFile::Source);
  // writer << newline;
  // forward_decl_aliases(writer, nodes);
  // writer << newline;
  // forward_declare_funcs(writer, tree, GeneratedFile::Source);
  // writer << newline;
}

auto forward_declare_internal(std::ostream& writer, const SyntaxTree& tree) -> void {
  writer << "/*" << newline << " *  Forward Declarations" << newline << " */" << newline << newline;

  forward_declare_vars(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
  forward_decl_structs(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
  forward_decl_objects(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
  //forward_decl_aliases(writer, nodes);
  //writer << newline;
  forward_declare_funcs(writer, tree, GeneratedFile::HeaderInternal);
  //writer << newline;
}

auto write_definitions(std::ostream& writer, const SyntaxTree& source) -> void {
  for (auto& var : source.variables()) {
    write_def(writer, deref(var));
  }

  for (auto& str : source.structs()) {
    writer << newline;
    write_struct_definition(writer, deref(str));
  }

  for (auto& object : source.objects()) {
    writer << newline;
    write_object_definition(writer, deref(object));
  }

  for (auto& fn : source.functions()) {
    writer << newline;
    write_definition(writer, deref(fn));
  }
}

auto write_source_header(std::ostream& writer, const fs::path& rel_path) -> void {
  writer << "/*" << newline << " *  Generated by Typhon Compiler" << newline
         << " *      Source File : " << rel_path << newline << " */" << newline << newline;
}

const auto includes = std::vector<std::string_view>{"<cstdint>"};

auto write_includes(std::ostream& writer) {
  for (auto& include : includes) {
    writer << "#include " << include << newline;
  }
  if (!includes.empty()) {
    writer << newline;
  }
}

auto generate_source_file(const NameSpace& ns, const SyntaxTree& syntax_tree) -> void {
  auto& source        = deref(syntax_tree.source());
  auto& src_file_path = source.gen_source_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());
  auto writer = std::ofstream{src_file_path};

  TRACE_TIMER("Generator");
  write_source_header(writer, source.rel_path());

  writer << "#include " << ns.gen_header_path().filename() << newline << newline;

  forward_declare_source(writer, syntax_tree);
  write_definitions(writer, syntax_tree);
}

auto generate_internal_header(const NameSpace& ns, const SyntaxTree& syntax_tree) -> void {
  auto& source        = deref(syntax_tree.source());
  auto& src_file_path = source.gen_header_internal_path();
  TRACE_PRINT("Generating : " << src_file_path << std::endl);

  fs::create_directories(src_file_path.parent_path());
  auto writer = std::ofstream{src_file_path};

  TRACE_TIMER("Generator");
  write_source_header(writer, source.rel_path());

  writer << "#pragma once" << newline << newline;

  writer << "#include \"" << ns.gen_header_path().filename().string() << '"' << newline << newline;

  forward_declare_internal(writer, syntax_tree);
  //write_definitions(writer, syntax_tree);
}

auto generate_namespace_header(const NameSpace& ns) {
  auto writer = std::ofstream{ns.gen_header_path()};

  write_source_header(writer, {});
  writer << "#pragma once" << newline << newline;

  writer << "#include \"../../../__builtins.hpp\"" << newline << newline;

  for (auto& ptree : ns.trees()) {
    auto& tree = deref(ptree);
    writer << "#include \"" << deref(tree.source()).gen_header_internal_path().filename().string()
           << '"' << newline;
  }
}

auto generate(const NameSpace& ns) -> void {
  generate_namespace_header(ns);
  for (auto& ptree : ns.trees()) {
    auto& tree = deref(ptree);
    generate_internal_header(ns, tree);
    generate_source_file(ns, tree);
  }

  for (auto& psub : ns.sub_spaces()) {
    generate(deref(psub));
  }
}

auto generate(const ProjectTree& source) -> void { generate(deref(source.root())); }
